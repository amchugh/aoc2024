
use std::collections::HashMap;

use crate::days::Solution;

#[derive(Debug, Clone, PartialEq, Eq)]
enum Op {
    AND, XOR, OR
}

impl Op {
    fn from(x: &str) -> Op {
        match x {
            "AND" => Op::AND,
            "XOR" => Op::XOR,
            "OR" => Op::OR,
            _ => {panic!("Invalid operation");}
        }
    }

    fn compute(&self, left: bool, right: bool) -> bool {
        match &self {
            Op::AND => left && right,
            Op::XOR => left ^ right,
            Op::OR => left || right,
        }
    }
}

#[derive(Debug, Clone)]
struct Gate {
    operation: Op,
    left: String,
    right: String,
    output: String
}

impl Gate {
    fn from(x: &str) -> Gate {
        let mut itr = x.split(" ");
        let left = itr.next().unwrap().to_owned();
        let operation = Op::from(itr.next().unwrap());
        let right = itr.next().unwrap().to_owned();
        let arrow = itr.next().unwrap();
        assert!(arrow == "->");
        let output = itr.next().unwrap().to_owned();
        Gate { operation, left, right, output }
    }

    fn compute(&self, left: bool, right: bool) -> bool {
        self.operation.compute(left, right)
    }
}

#[derive(Debug)]
pub struct Day24 {
    // State generated by `parse_input`
    initial_state: HashMap<String, bool>,
    gates: Vec<Gate>,
    all_off_state: HashMap<String, bool>,
}

impl Day24 {
    // Needed for creating a blank day
    pub fn new() -> Day24 {
        Day24 { initial_state: HashMap::new(), gates: vec![], all_off_state: HashMap::new() }
    }

    fn evaluate(mut state: HashMap<String, bool>, gates: &Vec<Gate>) -> HashMap<String, bool> {
        let mut unsolved_gates = gates.clone();

        loop {
            // Keep track of all the gates we didn't get to
            let mut unsolvable = vec![];
            let unsolved_count = unsolved_gates.len();

            // Go through every gate and see if we can evaluate it
            for gate in unsolved_gates {
                if let Some(left) = state.get(&gate.left) {
                    if let Some(right) = state.get(&gate.right) {
                        let v = gate.compute(*left, *right);
                        state.insert(gate.output, v);
                        continue;
                    }
                }
                unsolvable.push(gate);
            }

            // If we didn't solve any new gates, we must be done.
            if unsolvable.len() == unsolved_count {
                break;
            }
            unsolved_gates = unsolvable;
        }

        state
    }

    fn extract_number(state: &HashMap<String, bool>) -> u64 {
        let mut total = 0;
        for (label, value) in state {
            if label.starts_with("z") && *value {
                // Take the rest as a number
                let magnitude = label.split_at(1).1.parse().unwrap();
                total += 2_u64.pow(magnitude);
            }
        }
        total
    }

    fn run_with_numbers(&self, gates: &Vec<Gate>, x: u64, y: u64) -> u64 {
        // Create the right initial state
        let mut state = self.all_off_state.clone();
        let var_count = self.all_off_state.len() / 2;
        for idx in 0..var_count {
            let selected_bit = 2_u64.pow(idx as u32);
            if x & selected_bit != 0 {
                state.insert(format!("x{:02}", idx), true);
            }
            if y & selected_bit != 0 {
                state.insert(format!("y{:02}", idx), true);
            }
        }
        // Run
        Self::extract_number(&Self::evaluate(state, gates))
    }

    fn find_output(gates: &Vec<Gate>, input_1: &str, input_2: &str, operation: Op) -> Option<String> {
        Some(gates.iter().filter(|x| {
            x.operation == operation &&
            ((x.left == *input_1 && x.right == *input_2) || 
            (x.right == *input_1 && x.left == *input_2))
        }).next()?.output.clone())
    }
}

impl Solution for Day24 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.initial_state = HashMap::new();
        self.gates = vec![];
        self.all_off_state = HashMap::new();
    }

    fn parse_input(&mut self, file_contents: &str) {
        let mut itr = file_contents.split("\n\n");

        let initials = itr.next().unwrap().split("\n").map(|x| {
            let mut itr = x.split(": ");
            let label = itr.next().unwrap().to_owned();
            let state: bool = itr.next().unwrap() == "1";
            (label, state)
        });

        for initial in initials {
            self.initial_state.insert(initial.0.clone(), initial.1);
            self.all_off_state.insert(initial.0, false);
        }

        self.gates = itr.next().unwrap().split("\n").map(|x| Gate::from(x)).collect();
    }

    fn part1(&self) -> String {
        let state = Self::evaluate(self.initial_state.clone(), &self.gates);
        Self::extract_number(&state).to_string()
    }

    fn part2(&self) -> String {
        #[cfg(debug_assertions)]
        {
            // Look at some statistics
            let state = Self::evaluate(self.initial_state.clone(), &self.gates);
            // Get the number of x and y inputs
            let x_outputs = state.iter().filter(|x| x.0.starts_with("x")).count();
            let y_outputs = state.iter().filter(|x| x.0.starts_with("y")).count();
            let z_outputs = state.iter().filter(|x| x.0.starts_with("z")).count();
            assert!(x_outputs + 1 == z_outputs);
            assert!(y_outputs + 1 == z_outputs);
            // Make sure that all the x and y inputs appear in the initial state
            let x_inputs = self.initial_state.iter().filter(|x| x.0.starts_with("x")).count();
            let y_inputs = self.initial_state.iter().filter(|x| x.0.starts_with("y")).count();
            assert!(x_inputs == x_outputs);
            assert!(y_inputs == y_outputs);
            assert!(self.initial_state.len() == x_inputs + y_inputs);
            // The gates for a full adder are the following
            // z_i = x_i XOR y_i XOR c_i-1
            // c_i = (x_i AND y_i) OR (c_i-1 AND (x_i XOR y_i))
            // For a half-adder, they are the following:
            // z_0 = x_0 OR y_0
            // c_0 = x_0 AND y_0
            // This requires 5 gates (as x_i XOR y_i is reused).
            // GATE1       : x_i XOR y_i
            // GATE2       : x_i AND y_i
            // GATE3       : c_i-1 AND GATE1
            // GATE4 (c_i) : GATE2 OR GATE3
            // GATE5 (z_i) : GATE1 XOR c_i-1
            // We have one initial half-adder (2)
            // The rest are full-adders. 
            // The last bit is free out of the carry flag.
            assert!(self.gates.len() == 2 + (z_outputs - 2) * 5);
            // Zero input should give all the right numbers. 
            // This assures us that if x_i..x_j and y_i..y_j are 0, then z_i..z_j will be 0 too.
            let zero_output = Self::extract_number(&Self::evaluate(self.all_off_state.clone(), &self.gates));
            assert!(zero_output == 0);
            // Also, the error is never in z_0 or c_0
            assert!(self.run_with_numbers(&self.gates, 0, 0) == 0);
            assert!(self.run_with_numbers(&self.gates, 1, 0) == 1);
            assert!(self.run_with_numbers(&self.gates, 1, 1) == 2);
            assert!(self.run_with_numbers(&self.gates, 0, 1) == 1);
        }

        let mut corrected_gates = self.gates.clone();
        let mut swaps_remaining = 4;
        let mut incorrect_outputs: Vec<String> = vec![];
        incorrect_outputs.reserve(swaps_remaining * 2);

        // Find the first carry flag
        let first_carry = Self::find_output(&corrected_gates, "x00", "y00", Op::AND).unwrap();
        let mut carry_flag_names = vec![first_carry];

        let mut good_bits = 1;

        // Because of our assumptions, we do not need to search the whole bit space. 
        // z_i-1 is not dependent on z_i. This does not work vice-versa.
        // This means that if bits z_0 - z_i are correct, we do not need to check them.
        while swaps_remaining > 0 {
            let xinp = format!("x{:02}", good_bits);
            let yinp = format!("y{:02}", good_bits);

            // Test the first bit pair we are unsure about
            let inp = 2_u64.pow(good_bits);
            let x_ok = self.run_with_numbers(&corrected_gates, inp, 0) == inp;
            let y_ok = self.run_with_numbers(&corrected_gates, 0, inp) == inp;
            let carry_ok = self.run_with_numbers(&corrected_gates, inp, inp) == inp * 2;
            if x_ok && y_ok && carry_ok {
                // Need to find the carry flag name for future work
                let gate1output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::XOR).unwrap();
                let gate2output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::AND).unwrap();
                let gate3output = Self::find_output(&corrected_gates, &carry_flag_names[good_bits as usize - 1], &gate1output, Op::AND).unwrap();
                let carry_flag = Self::find_output(&corrected_gates, &gate2output, &gate3output, Op::OR).unwrap();
                carry_flag_names.push(carry_flag);

                good_bits += 1;
                continue;
            }

            // Need to find the right gate to swap
            if !carry_ok {
                // Something is wrong with the carry gate.
                // GATE1       : x_i XOR y_i
                // GATE2       : x_i AND y_i
                // GATE3       : c_i-1 AND GATE1
                // GATE4 (c_i) : GATE2 OR GATE3
                // GATE5 (z_i) : GATE1 XOR c_i-1
                // Specifically, GATE4 has the wrong output.

                // Get the carry flag name that we have
                let bad_carry_flag_name;
                {
                    let gate1output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::XOR).unwrap();
                    let gate2output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::AND).unwrap();
                    let gate3output = Self::find_output(&corrected_gates, &carry_flag_names[good_bits as usize - 1], &gate1output, Op::AND).unwrap();
                    bad_carry_flag_name = Self::find_output(&corrected_gates, &gate2output, &gate3output, Op::OR).unwrap();
                }

                // Get the carry flag name from the next set of gates
                let expected_carry_flag_name;
                {
                    let xinp = format!("x{:02}", good_bits + 1);
                    let yinp = format!("y{:02}", good_bits + 1);
                    let gate1output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::XOR).unwrap();
                    // The expected carry flag name in contained in the gate3 inputs
                    let mut itr = corrected_gates.iter().filter(|x| x.operation == Op::AND && (x.left == gate1output || x.right == gate1output));
                    let gate3 = itr.next().unwrap();
                    assert!(itr.next().is_none());

                    if gate3.left == gate1output {
                        expected_carry_flag_name = gate3.right.clone();
                    } else {
                        expected_carry_flag_name = gate3.left.clone();
                    }
                }

                assert!(expected_carry_flag_name != bad_carry_flag_name);

                // Swap them!
                let gate = corrected_gates.iter_mut().filter(|x| x.output == expected_carry_flag_name).next().unwrap();
                let id = gate.left.clone();
                gate.output = bad_carry_flag_name.clone();

                let gate;
                let mut itr = corrected_gates.iter_mut().filter(|x| x.output == bad_carry_flag_name);
                let first = itr.next().unwrap();
                if first.left == id {
                    gate = itr.next().unwrap();
                } else {
                    gate = first;
                }
                gate.output = expected_carry_flag_name.clone();

                incorrect_outputs.push(bad_carry_flag_name);
                incorrect_outputs.push(expected_carry_flag_name);

                // // There should be two gates with that flag.
                // let mut carry_gates = corrected_gates.iter().filter(|x| x.left == carry_flag || x.right == carry_flag);
                // let first = carry_gates.next().unwrap();
                // let second = carry_gates.next().unwrap();
                // assert!(carry_gates.next().is_none());
                // dbg!(first, second);

                // let output = self.run_with_numbers(&corrected_gates, inp, inp);
                // let bit_flipped = output.ilog2() - 1;
                // let should_flip = good_bits + 1;

                // let bad_output = format!("z{:02}", bit_flipped);
                // let good_output = format!("z{:02}", should_flip);

                // // Should be the z_{bit flipped} gate.
                // let bad_gate = corrected_gates.iter_mut().filter(|x| x.output == bad_output).next().unwrap();
                // assert!(bad_gate.left == bad_carry_flag_name || bad_gate.right == bad_carry_flag_name);
                // bad_gate.output = good_output;
                // // And we want to switch it with the other z_ gate.
                // let switch_gate = corrected_gates.iter_mut().filter(|x| x.output == good_output).next().unwrap();


                // // Let's first find where gate 1 goes
                // let gate1output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::XOR).unwrap();
                // let gate2output = Self::find_output(&corrected_gates, &xinp, &yinp, Op::AND).unwrap();
                // // The rest are not guaranteed
                // let gate3output = Self::find_output(&corrected_gates, &carry_flag_names[good_bits as usize - 1], &gate1output, Op::AND);
                // let gate3output = gate3output.unwrap();
                // let carry_flag = Self::find_output(&corrected_gates, &gate2output, &gate3output, Op::OR);
                // let carry_flag = carry_flag.unwrap();
                // // If we've successfully found 
            }
            else {
                assert!(x_ok || y_ok);
                if !x_ok {
                    panic!();
                } else {
                    assert!(!y_ok);
                    panic!();
                }
            }

            dbg!(good_bits, x_ok, y_ok, carry_ok);

            swaps_remaining -= 1;


            // let x_changed = Self::enable_gate(self.all_off_state.clone(), format!("x{:02}", good_bits));
            // let expected = 2_u64.pow(good_bits);
            // let actual = Self::extract_number(&Self::evaluate(x_changed, &corrected_gates));
            // let diff = expected ^ actual;
            // if diff != 0 {
            //     let wrong_idx = dbg!(actual.ilog2());
            //     let wrong_bit_on = format!("z{:02}", wrong_idx);
            //     let wrong_bit_off = format!("z{:02}", good_bits);

            //     corrected_gates.iter_mut().filter(|x| x.output == wrong_bit_on).next().unwrap().output = "tmp".to_owned();
            //     corrected_gates.iter_mut().filter(|x| x.output == wrong_bit_off).next().unwrap().output = wrong_bit_on.clone();
            //     corrected_gates.iter_mut().filter(|x| x.output == "tmp").next().unwrap().output = wrong_bit_off.clone();

            //     incorrect_outputs.push(wrong_bit_off);
            //     incorrect_outputs.push(wrong_bit_on);
            //     swaps_remaining -= 1;
            // } else {
            //     good_bits += 1;
            // }
        }

        #[cfg(debug_assertions)]
        {
            // Check the first bits
            assert!(self.run_with_numbers(&corrected_gates, 0, 0) == 0);
            assert!(self.run_with_numbers(&corrected_gates, 1, 0) == 1);
            assert!(self.run_with_numbers(&corrected_gates, 1, 1) == 2);
            assert!(self.run_with_numbers(&corrected_gates, 0, 1) == 1);
            // Check the remaining bits in a group
            let bit_count = self.all_off_state.len() / 2;
            for idx in 0..bit_count-1 {
                let last = 2_u64.pow(idx as u32);
                let current = last * 2;
                let next = current * 2;

                assert!(self.run_with_numbers(&corrected_gates, current, 0) == current);
                assert!(self.run_with_numbers(&corrected_gates, current, current) == next);
                assert!(self.run_with_numbers(&corrected_gates, 0, current) == current);
                // And check with the carry flags
                assert!(self.run_with_numbers(&corrected_gates, current, last) == current + last);
                assert!(self.run_with_numbers(&corrected_gates, last, current) == current + last);
                assert!(self.run_with_numbers(&corrected_gates, current + last, last) == next);
                assert!(self.run_with_numbers(&corrected_gates, last, current + last) == next);
                assert!(self.run_with_numbers(&corrected_gates, current + last, current + last) == next + current);
            }
        }

        incorrect_outputs.sort();
        incorrect_outputs.iter().skip(1).fold(incorrect_outputs.first().unwrap().to_owned(), |acc, x| format!("{},{}", acc, x))
    }
}
