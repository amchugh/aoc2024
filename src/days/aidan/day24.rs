
use std::collections::HashMap;

use crate::days::Solution;

#[derive(Debug, Clone)]
enum Op {
    AND, XOR, OR
}

impl Op {
    fn from(x: &str) -> Op {
        match x {
            "AND" => Op::AND,
            "XOR" => Op::XOR,
            "OR" => Op::OR,
            _ => {panic!("Invalid operation");}
        }
    }

    fn compute(&self, left: bool, right: bool) -> bool {
        match &self {
            Op::AND => left && right,
            Op::XOR => left ^ right,
            Op::OR => left || right,
        }
    }
}

#[derive(Debug, Clone)]
struct Gate {
    operation: Op,
    left: String,
    right: String,
    output: String
}

impl Gate {
    fn from(x: &str) -> Gate {
        let mut itr = x.split(" ");
        let left = itr.next().unwrap().to_owned();
        let operation = Op::from(itr.next().unwrap());
        let right = itr.next().unwrap().to_owned();
        let arrow = itr.next().unwrap();
        assert!(arrow == "->");
        let output = itr.next().unwrap().to_owned();
        Gate { operation, left, right, output }
    }

    fn compute(&self, left: bool, right: bool) -> bool {
        self.operation.compute(left, right)
    }
}

#[derive(Debug)]
pub struct Day24 {
    // State generated by `parse_input`
    initial_state: HashMap<String, bool>,
    gates: Vec<Gate>,
}

impl Day24 {
    // Needed for creating a blank day
    pub fn new() -> Day24 {
        Day24 { initial_state: HashMap::new(), gates: vec![] }
    }
}

impl Solution for Day24 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.initial_state = HashMap::new();
        self.gates = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        let mut itr = file_contents.split("\n\n");

        let initials = itr.next().unwrap().split("\n").map(|x| {
            let mut itr = x.split(": ");
            let label = itr.next().unwrap().to_owned();
            let state: bool = itr.next().unwrap() == "1";
            (label, state)
        });

        for initial in initials {
            self.initial_state.insert(initial.0, initial.1);
        }

        self.gates = itr.next().unwrap().split("\n").map(|x| Gate::from(x)).collect();
    }

    fn part1(&self) -> String {
        let mut state = self.initial_state.clone();
        let mut unsolved_gates = self.gates.clone();

        loop {
            // Keep track of all the gates we didn't get to
            let mut unsolvable = vec![];
            let unsolved_count = unsolved_gates.len();

            // Go through every gate and see if we can evaluate it
            for gate in unsolved_gates {
                if let Some(left) = state.get(&gate.left) {
                    if let Some(right) = state.get(&gate.right) {
                        let v = gate.compute(*left, *right);
                        state.insert(gate.output, v);
                        continue;
                    }
                }
                unsolvable.push(gate);
            }

            // If we didn't solve any new gates, we must be done.
            if unsolvable.len() == unsolved_count {
                break;
            }
            unsolved_gates = unsolvable;
        }

        // Assemble the solution
        let mut total = 0;
        for (label, value) in state {
            if label.starts_with("z") && value {
                // Take the rest as a number
                let magnitude = label.split_at(1).1.parse().unwrap();
                total += 2_usize.pow(magnitude);
            }
        }
        total.to_string()
    }

    fn part2(&self) -> String {
        dbg!(&self.gates.len());
        "Not Implemented".to_string()
    }
}
