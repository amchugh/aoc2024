
use crate::days::Solution;

const SEARCHING: [char; 4] = ['X', 'M', 'A', 'S'];
const SEARCHING_BACKWARDS: [char; 4] = ['S', 'A', 'M', 'X'];

#[derive(Debug)]
pub struct Day4 {
    // State generated by `parse_input`
    grid: Vec<Vec<char>>,
}

impl Day4 {
    // Needed for creating a blank day
    pub fn new() -> Day4 {
        Day4 { grid: vec![] }
    }

    fn test(&self, startx: usize, starty: usize, dx: i64, dy: i64, backwards: bool) -> bool {
        // Figure out the letters we are looking for
        let searching;
        if backwards {
            searching = &SEARCHING_BACKWARDS;
        } else {
            searching = &SEARCHING;
        }
        // Ensure they appear in-order
        for i in 0..4 {
            let y = starty as i64 + dy * i;
            let x = startx as i64 + dx * i;
            let row =self.grid.get(y as usize);
            if row.is_none() {
                return false;
            } 
            let c = row.unwrap().get(x as usize);
            if c.is_none() || *c.unwrap() != searching[i as usize] {
                return false;
            }
        }
        true
    }

    fn other(c: char) -> Option<char> {
        match c {
            'M' => Some('S'),
            'S' => Some('M'),
            _ => None
        }
    }
}

impl Solution for Day4 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.grid = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        self.grid = file_contents.split("\n").map(|line| {
            line.chars().collect()
        }).collect();
    }

    fn part1(&self) -> String {
        let width = self.grid[0].len();
        let height = self.grid.len();

        let mut total = 0;

        for y in 0..height {
            for x in 0..width {
                if self.test(x, y, 0, 1, false) {
                    total += 1;
                }
                if self.test(x, y, 0, 1, true) {
                    total += 1;
                }
                if self.test(x, y, 1, 0, false) {
                    total += 1;
                }
                if self.test(x, y, 1, 0, true) {
                    total += 1;
                }
                if self.test(x, y, 1, 1, false) {
                    total += 1;
                }
                if self.test(x, y, 1, 1, true) {
                    total += 1;
                }
                if x >= 3 {
                    if self.test(x, y, -1, 1, false) {
                        total += 1;
                    }
                    if self.test(x, y, -1, 1, true) {
                        total += 1;
                    }
                }
            }
        }

        total.to_string()
    }

    fn part2(&self) -> String {
        let width = self.grid[0].len();
        let height = self.grid.len();

        // Find every 'A' in the inner square
        let mut total = 0;
        for y in 1..height-1 {
            for x in 1..width-1 {
                if self.grid[y][x] == 'A' {
                    // Check the corners
                    let needed = Self::other(self.grid[y-1][x-1]);
                    if needed.is_none() {
                        continue
                    }
                    let needed = needed.unwrap();
                    if self.grid[y+1][x+1] != needed {
                        continue
                    }

                    // Check the other corner
                    let needed = Self::other(self.grid[y+1][x-1]);
                    if needed.is_none() {
                        continue
                    }
                    let needed = needed.unwrap();
                    if self.grid[y-1][x+1] != needed {
                        continue
                    }

                    total += 1;
                }
            }
        }

        total.to_string()
    }
}
