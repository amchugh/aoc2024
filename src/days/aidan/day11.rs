use std::collections::HashMap;

use crate::days::Solution;

#[derive(Debug, Clone)]
pub struct Day11 {
    // State generated by `parse_input`
    initial: HashMap<usize, usize>
}

impl Day11 {
    // Needed for creating a blank day
    pub fn new() -> Day11 {
        Day11 {
            initial: HashMap::new(),
        }
    }

    fn blink(&self, count: usize) -> usize {
        // Create the initial state
        let mut stones = self.initial.clone();

        for _ in 0..count {
            // Step all the stones
            let mut next_stones = HashMap::new();
            for (current_stone, count) in stones {
                let (next, split) = Self::blink_stone(current_stone);

                match next_stones.get_mut(&next) {
                    Some(next_count) => *next_count += count,
                    None => { next_stones.insert(next, count); }
                };

                if let Some(split) = split {
                    match next_stones.get_mut(&split) {
                        Some(next_count) => *next_count += count,
                        None => { next_stones.insert(split, count); }
                    };
                }
            }
            stones = next_stones;
        }

        let mut total = 0;
        for (_, count) in stones {
            total += count;
        }
        total
    }

    fn blink_stone(stone: usize) -> (usize, Option<usize>) {
        /*
         * If the stone is engraved with the number 0, it is replaced by a stone engraved with the number 1.
         *
         * If the stone is engraved with a number that has an even number of digits, it is replaced by two stones.
         *  The left half of the digits are engraved on the new left stone, and the right half of the digits are
         *  engraved on the new right stone. (The new numbers don't keep extra leading zeroes: 1000 would become
         *  stones 10 and 0.)
         *
         * If none of the other rules apply, the stone is replaced by a new stone; the old stone's number
         *  multiplied by 2024 is engraved on the new stone.
         */
        if stone == 0 {
            (1, None)
        } else if stone.to_string().len() % 2 == 0 {
            let len = stone.to_string().len();
            let each_side = len / 2;
            let parts = (10 as usize).pow(each_side as u32);
            let left = stone / parts;
            let right = stone % parts;
            assert!(left * parts + right == stone);
            (left, Some(right))
        } else {
            (stone * 2024, None)
        }
    }
}

impl Solution for Day11 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.initial = HashMap::new();
    }

    fn parse_input(&mut self, file_contents: &str) {
        let initial = file_contents.split(" ").map(|x| x.parse::<usize>().unwrap()).collect::<Vec<usize>>();
        for stone in initial {
            match self.initial.get_mut(&stone) {
                Some(count) => *count += 1,
                None => { self.initial.insert(stone, 1); }
            };
        }
    }

    fn part1(&self) -> String {
        self.blink(25).to_string()
    }

    fn part2(&self) -> String {
        self.blink(75).to_string()
    }
}