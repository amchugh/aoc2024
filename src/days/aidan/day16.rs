
use std::{cmp::Reverse, collections::HashMap};

use priority_queue::PriorityQueue;

use crate::days::Solution;

const INFINITY: usize = 10e10 as usize;

#[derive(Clone)]
enum Direction {
    North, South, East, West
}

impl Direction {
    fn next(&self) -> Direction {
        match &self {
            Direction::North => Direction::East,
            Direction::South => Direction::West,
            Direction::East => Direction::South,
            Direction::West => Direction::North,
        }
    }
    fn translate(&self, pos: &(usize, usize)) -> (usize, usize) {
        match &self {
            Direction::North => (pos.0, pos.1 - 1),
            Direction::South => (pos.0, pos.1 + 1),
            Direction::East =>  (pos.0 + 1, pos.1),
            Direction::West =>  (pos.0 - 1, pos.1),
        }
    }
}

#[derive(Debug)]
pub struct Day16 {
    // State generated by `parse_input`
    grid: Vec<Vec<char>>,
    width: usize,
    height: usize,
}

impl Day16 {
    // Needed for creating a blank day
    pub fn new() -> Day16 {
        Day16 { grid: vec![], width: 0, height: 0 }
    }

    fn blocked(&self, x: usize, y: usize) -> bool {
        *self.grid.get(y).unwrap().get(x).unwrap() == '#'
    }
}

impl Solution for Day16 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.grid = vec![];
        self.width = 0;
        self.height = 0;
    }

    fn parse_input(&mut self, file_contents: &str) {
        self.grid = file_contents.split("\n").map(|line| {
            line.chars().collect()
        }).collect();
        self.width = self.grid[0].len();
        self.height = self.grid.len();
    }

    fn part1(&self) -> String {
        let start = (1, self.height - 2);
        let end = (self.width - 2, 1);

        // Dijkstra's algorithm with a turning penalty
        let mut direction_entering = HashMap::new();
        direction_entering.insert(start, Direction::East);

        // 1. Create a set of all unvisited nodes: the unvisited set.
        let mut unvisited = PriorityQueue::new();

        // 2. Assign to every node a distance from start value: for the starting node, 
        // it is zero, and for all other nodes, it is infinity, since initially no path 
        // is known to these nodes. During execution, the distance of a node N is the 
        // length of the shortest path discovered so far between the starting node and N.
        for y in 0..self.height {
            for x in 0..self.width {
                if !self.blocked(x, y) && (x, y) != start {
                    unvisited.push((x, y), Reverse(INFINITY));
                }
            }
        }
        unvisited.push(start, Reverse(0));
        assert!(unvisited.peek() == Some((&start, &Reverse(0))));

        // 3. From the unvisited set, select the current node to be the one with the smallest 
        // (finite) distance; initially, this is the starting node (distance zero). If the 
        // unvisited set is empty, or contains only nodes with infinite distance (which are unreachable), 
        // then the algorithm terminates by skipping to step 6. If the only concern is the path 
        // to a target node, the algorithm terminates once the current node is the target node. 
        // Otherwise, the algorithm continues.
        loop {
            let closest = unvisited.pop();
            if closest.is_none() {
                panic!("Failed to find a path to target node")
            }
            let closest = closest.unwrap();

            // Return when we reach the end
            if closest.0 == end {
                return closest.1.0.to_string();
            }

            // Ensure that we had a best direction with which to reach this tile
            let best_direction = direction_entering.get(&closest.0).unwrap().clone();

            // The next tile, if its there, only has a penalty of 1. Try to update.
            {
                let forward = best_direction.translate(&closest.0);
                let candidate_priority = closest.1.0 + 1;
                if let Some(current_priority) = unvisited.get_priority(&forward) {
                    if candidate_priority < current_priority.0 {
                        unvisited.change_priority(&forward, Reverse(candidate_priority));
                        direction_entering.insert(forward, best_direction.clone());
                    } 
                }
            }

            // Now do the other three directions
            let candidate_priority = closest.1.0 + 1001;
            let mut direction = best_direction;
            for _ in 0..3 {
                direction = direction.next();
                let position = direction.translate(&closest.0);
                if let Some(current_priority) = unvisited.get_priority(&position) {
                    if candidate_priority < current_priority.0 {
                        unvisited.change_priority(&position, Reverse(candidate_priority));
                        direction_entering.insert(position, direction.clone());
                    } 
                }
            }
        }
    }

    fn part2(&self) -> String {
        "Not Implemented".to_string()
    }
}
