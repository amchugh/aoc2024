
use crate::days::Solution;

#[derive(Debug)]
pub struct Day19 {
    // State generated by `parse_input`
    pieces: Vec<String>,
    goals: Vec<String>
}

impl Day19 {
    // Needed for creating a blank day
    pub fn new() -> Day19 {
        Day19 { pieces: vec![], goals: vec![] }
    }

    fn find_path_to_end(finishing_places_by_start_idx: &Vec<Vec<Option<usize>>>, goal: usize, start_idx: usize) -> bool {
        if start_idx == goal {
            return true;
        }
        assert!(start_idx < goal);

        for next in finishing_places_by_start_idx[start_idx].iter() {
            if let Some(idx) = next {
                if Self::find_path_to_end(finishing_places_by_start_idx, goal, *idx) {
                    return true;
                }
            }
        }

        return false;
    }
}

impl Solution for Day19 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.pieces = vec![];
        self.goals = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        let mut itr = file_contents.split("\n\n");
        self.pieces = itr.next().unwrap().split(", ").map(|x| x.to_string()).collect();
        self.goals = itr.next().unwrap().split("\n").map(|x| x.to_string()).collect();
    }

    fn part1(&self) -> String {
        let mut total = 0;
        for goal in &self.goals {
            let mut finishing_places_by_start_idx = vec![];
            // Build the vector
            for idx in 0..goal.len() {
                let mut row = vec![];
                for piece in &self.pieces {
                    // So, if the goal started at `idx`, if we can apply the piece, where would it end?
                    let ending = if goal[idx..].starts_with(piece) {
                        Some(idx + piece.len())
                    } else {
                        None
                    };
                    row.push(ending)
                }
                finishing_places_by_start_idx.push(row);
            }
            if Self::find_path_to_end(&finishing_places_by_start_idx, goal.len(), 0) {
                total += 1;
            }
        }

        total.to_string()
    }

    fn part2(&self) -> String {
        let mut total = 0;
        for goal in &self.goals {
            let mut finishing_places_by_start_idx = vec![];
            // Build the vector
            for idx in 0..goal.len() {
                let mut row = vec![];
                for piece in &self.pieces {
                    // So, if the goal started at `idx`, if we can apply the piece, where would it end?
                    let ending = if goal[idx..].starts_with(piece) {
                        Some(idx + piece.len())
                    } else {
                        None
                    };
                    row.push(ending)
                }
                finishing_places_by_start_idx.push(row);
            }
            // Find how many paths to end by vector, backwards
            let mut paths_to_end_by_idx = vec![0; finishing_places_by_start_idx.len()];
            for idx in (0..paths_to_end_by_idx.len()).rev() {
                let mut total: usize = 0;
                for finishing in &finishing_places_by_start_idx[idx] {
                    if let Some(finishing) = finishing {
                        if *finishing == goal.len() {
                            total += 1;
                        }
                        else {
                            assert!(*finishing > idx);
                            assert!(*finishing < paths_to_end_by_idx.len());
                            total += paths_to_end_by_idx[*finishing];
                        }
                    }
                }
                paths_to_end_by_idx[idx] = total;
            }
            total += paths_to_end_by_idx[0];
        }

        total.to_string()
    }
}
