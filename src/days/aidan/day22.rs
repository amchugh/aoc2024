
use std::collections::HashMap;

use crate::days::Solution;

const MOD: u64 = 16777216;

#[derive(Debug)]
pub struct Day22 {
    // State generated by `parse_input`
    initial_numbers: Vec<i64>
}

impl Day22 {
    // Needed for creating a blank day
    pub fn new() -> Day22 {
        Day22 { initial_numbers: vec![] }
    }

    fn next(secret_number: i64) -> i64 {
        let secret_number = secret_number as u64;
        let secret_number = ((secret_number * 64) ^ secret_number) % MOD;
        let secret_number = ((secret_number / 32) ^ secret_number) % MOD;
        let secret_number = ((secret_number * 2048) ^ secret_number) % MOD;
        secret_number as i64
    }
}

impl Solution for Day22 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.initial_numbers = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        self.initial_numbers = file_contents.split("\n").map(|x| x.parse().unwrap()).collect();
    }

    fn part1(&self) -> String {
        self.initial_numbers.iter().map(|x| {
            let mut number = *x;
            for _ in 0..2000 {
                number = Self::next(number);
            }
            number
        }).sum::<i64>().to_string()
    }

    fn part2(&self) -> String {
        let mut values = HashMap::new();

        for initial in &self.initial_numbers {
            let mut seen = HashMap::new();
            let mut differences = (0, 0, 0, 0);

            // Do the first 4 by hand
            // #0
            let mut last = *initial;
            // #1
            let mut next = Self::next(last);
            differences.0 = (next % 10) - (last % 10);

            last = next;
            // #2
            next = Self::next(last);
            differences.1 = (next % 10) - (last % 10);

            last = next;
            // #3
            next = Self::next(last);
            differences.2 = (next % 10) - (last % 10);

            last = next;
            // #4
            next = Self::next(last);
            differences.3 = (next % 10) - (last % 10);

            for _ in 4..2000 {
                // If this is the first time we've seen this sequence, we get the value of the secret number
                if !seen.contains_key(&differences) {
                    seen.insert(differences, next % 10);
                }
                // Calculate the next
                last = next;
                next = Self::next(last);
                // Move the differences
                differences.0 = differences.1;
                differences.1 = differences.2;
                differences.2 = differences.3;
                differences.3 = (next % 10) - (last % 10);
            }

            // Update the hashmap
            for value in seen {
                if let Some(pair) = values.get_mut(&value.0) {
                    *pair += value.1;
                }
                else {
                    values.insert(value.0, value.1);
                }
            }
        }

        // Find the highest value
        values.iter().max_by(|x, y| x.1.cmp(y.1)).unwrap().1.to_string()
    }
}
