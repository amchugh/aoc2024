
use std::fmt::Debug;
use std::hash::{Hash, Hasher};
use std::collections::{HashMap, HashSet};

use crate::days::Solution;

#[derive(Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
struct NetworkThree {
    repr: String,
}

impl NetworkThree {
    fn from(a: &str, b: &str, c: &str) -> NetworkThree {
        let mut triple = [a, b, c];
        triple.sort();
        let repr = triple[0].to_owned() + triple[1] + triple[2];
        NetworkThree { repr }
    }

    #[allow(dead_code)]
    fn first(&self) -> &str {
        self.repr.split_at(2).0
    }

    #[allow(dead_code)]
    fn second(&self) -> &str {
        self.repr.split_at(2).1.split_at(2).0
    }

    #[allow(dead_code)]
    fn third(&self) -> &str {
        self.repr.split_at(4).1
    }
}

#[derive(Debug)]
pub struct Day23 {
    // State generated by `parse_input`
    outgoing: HashMap<String, HashSet<String>>
}

impl Day23 {
    // Needed for creating a blank day
    pub fn new() -> Day23 {
        Day23 { outgoing: HashMap::new() }
    }

    // https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm
    fn find_largest_clique(&self, r: HashSet<String>, mut p: HashSet<String>, mut x: HashSet<String>) -> Option<String> {
        if p.len() == 0 && x.len() == 0 {
            // Order and generate the result String
            let mut containing: Vec<&String> = r.iter().collect();
            containing.sort();
            let mut itr = containing.iter();
            itr.next();
            let result = itr.fold(
                containing.first().unwrap().to_string(),
                |acc, x| format!("{},{}", acc, x)
            ).to_owned();

            return Some(result);
        }

        let searching = p.clone();
        let mut best = String::new();

        for vertex in searching {
            // BronKerbosch1(R ⋃ {v}, P ⋂ N(v), X ⋂ N(v))
            let neighbor_set = self.outgoing.get(&vertex).unwrap();
            let mut next_r = r.clone();
            next_r.insert(vertex.clone());
            let next_p = p.intersection(&neighbor_set).cloned().collect();
            let next_x = x.intersection(&neighbor_set).cloned().collect();
            if let Some(result) = self.find_largest_clique(next_r, next_p, next_x) {
                if result.len() > best.len() {
                    best = result;
                }
            }
            // P := P \ {v}
            // X := X ⋃ {v}
            p.remove(&vertex);
            x.insert(vertex.clone());
        }

        Some(best)
    }
}

impl Solution for Day23 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.outgoing = HashMap::new();
    }

    fn parse_input(&mut self, file_contents: &str) {
        for line in file_contents.split("\n") {
            let mut itr = line.split("-");
            let left = itr.next().unwrap();
            let right = itr.next().unwrap();
            // Add both
            if let Some(set) = self.outgoing.get_mut(left) {
                set.insert(right.to_string());
            } else {
                let mut set = HashSet::new();
                set.insert(right.to_string());
                self.outgoing.insert(left.to_string(), set);
            }

            if let Some(set) = self.outgoing.get_mut(right) {
                set.insert(left.to_string());
            } else {
                let mut set = HashSet::new();
                set.insert(left.to_string());
                self.outgoing.insert(right.to_string(), set);
            }
        }
    }

    fn part1(&self) -> String {
        let mut threes: HashSet<NetworkThree> = HashSet::new();

        // Take every 2-pair and count the number that they have in common, removing from the list
        let mut starts_with_t = false;
        let mut itr1 = self.outgoing.iter();
        while let Some(left) = itr1.next() {
            starts_with_t = left.0.chars().next().unwrap() == 'c';
            let mut itr2 = itr1.clone();
            while let Some(right) = itr2.next() {
                starts_with_t = starts_with_t || right.0.chars().next().unwrap() == 'c';
                // Only count if these two are connected
                if left.1.contains(right.0) {
                    assert!(right.1.contains(left.0));
                    // Get all of the third-s
                    let shared = left.1.intersection(right.1);
                    for third in shared {
                        // We only want connections that contain a 't'
                        if starts_with_t || third.chars().next().unwrap() == 'c' {
                            threes.insert(NetworkThree::from(left.0, right.0, third));
                        }
                    }
                }
            }
        }

        // Debug only
        #[cfg(debug_assertions)]
        {
            for el in threes.iter() {
                let map = self.outgoing.get(el.first()).unwrap();
                assert!(map.contains(el.second()));
                assert!(map.contains(el.third()));
                let map = self.outgoing.get(el.second()).unwrap();
                assert!(map.contains(el.first()));
                assert!(map.contains(el.third()));
                let map = self.outgoing.get(el.third()).unwrap();
                assert!(map.contains(el.first()));
                assert!(map.contains(el.second()));
            }
        }

        threes.iter().count().to_string()
    }

    fn part2(&self) -> String {
        // The largest connected component can be determined by looking at the number of edges
        // a node has.
        let mut outgoing: Vec<(&String, &HashSet<String>)> = self.outgoing.iter().collect();
        outgoing.sort_by(|a, b| a.1.len().cmp(&b.1.len()));

        let r = HashSet::new();
        let p = self.outgoing.keys().cloned().collect::<HashSet<_>>();
        let x = HashSet::new();

        self.find_largest_clique(r, p, x).unwrap().to_string()
    }
}
