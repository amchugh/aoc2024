
use std::fmt::Debug;
use std::hash::{Hash, Hasher};
use std::collections::{HashMap, HashSet};

use crate::days::Solution;

#[derive(PartialOrd, Ord)]
// struct NetworkThree(String, String, String);
struct NetworkThree {
    repr: String,
    starts_with_t: bool,
}

impl NetworkThree {
    fn from(a: &str, b: &str, c: &str) -> NetworkThree {
        let mut triple = [a, b, c];
        triple.sort();
        let repr = triple[0].to_owned() + triple[1] + triple[2];
        let starts_with_t = a.starts_with("t") || b.starts_with("t") || c.starts_with("t");
        NetworkThree { repr, starts_with_t }
    }

    fn first(&self) -> &str {
        self.repr.split_at(2).0
    }

    fn second(&self) -> &str {
        self.repr.split_at(2).1.split_at(2).0
    }

    fn third(&self) -> &str {
        self.repr.split_at(4).1
    }
}

impl Debug for NetworkThree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // f.write_fmt(format_args!("({} {} {})", self.0, self.1, self.2))
        f.write_fmt(format_args!("{}", self.repr))
    }
}

impl Hash for NetworkThree {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // let total: u64 = self.0.chars().map(|x| x as u64).sum::<u64>() +
        // self.1.chars().map(|x| x as u64).sum::<u64>() +
        // self.2.chars().map(|x| x as u64).sum::<u64>();
        // total.hash(state)
        self.repr.hash(state)
    }
}

impl PartialEq for NetworkThree {
    fn eq(&self, other: &Self) -> bool {
        self.repr == other.repr
        // (self.0 == other.0 && self.1 == other.1 && self.2 == other.2) ||
        // (self.0 == other.0 && self.2 == other.1 && self.1 == other.2) ||
        // (self.1 == other.0 && self.2 == other.1 && self.0 == other.2) ||
        // (self.1 == other.0 && self.0 == other.1 && self.2 == other.2) ||
        // (self.2 == other.0 && self.0 == other.1 && self.1 == other.2) ||
        // (self.2 == other.0 && self.1 == other.1 && self.0 == other.2)
    }
}

impl Eq for NetworkThree {}

#[derive(Debug)]
pub struct Day23 {
    // State generated by `parse_input`
    outgoing: HashMap<String, HashSet<String>>
}

impl Day23 {
    // Needed for creating a blank day
    pub fn new() -> Day23 {
        Day23 { outgoing: HashMap::new() }
    }

    // https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm
    fn find_largest_clique(&self, r: HashSet<String>, mut p: HashSet<String>, mut x: HashSet<String>) -> Option<String> {
        if p.len() == 0 && x.len() == 0 {
            // Order and generate the result String
            let mut containing: Vec<&String> = r.iter().collect();
            containing.sort();
            let mut itr = containing.iter();
            itr.next();
            let result = itr.fold(
                containing.first().unwrap().to_string(),
                |acc, x| format!("{},{}", acc, x)
            ).to_owned();

            return Some(result);
        }

        let searching = p.clone();
        let mut best = String::new();

        for vertex in searching {
            // BronKerbosch1(R ⋃ {v}, P ⋂ N(v), X ⋂ N(v))
            let neighbor_set = self.outgoing.get(&vertex).unwrap();
            let mut next_r = r.clone();
            next_r.insert(vertex.clone());
            let next_p = p.intersection(&neighbor_set).cloned().collect();
            let next_x = x.intersection(&neighbor_set).cloned().collect();
            if let Some(result) = self.find_largest_clique(next_r, next_p, next_x) {
                if result.len() > best.len() {
                    best = result;
                }
            }
            // P := P \ {v}
            // X := X ⋃ {v}
            p.remove(&vertex);
            x.insert(vertex.clone());
        }

        Some(best)
    }
}

impl Solution for Day23 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.outgoing = HashMap::new();
    }

    fn parse_input(&mut self, file_contents: &str) {
        for line in file_contents.split("\n") {
            let mut itr = line.split("-");
            let left = itr.next().unwrap();
            let right = itr.next().unwrap();
            // Add both
            if let Some(set) = self.outgoing.get_mut(left) {
                set.insert(right.to_string());
            } else {
                let mut set = HashSet::new();
                set.insert(right.to_string());
                self.outgoing.insert(left.to_string(), set);
            }

            if let Some(set) = self.outgoing.get_mut(right) {
                set.insert(left.to_string());
            } else {
                let mut set = HashSet::new();
                set.insert(left.to_string());
                self.outgoing.insert(right.to_string(), set);
            }
        }
    }

    fn part1(&self) -> String {
        let mut threes: HashSet<NetworkThree> = HashSet::new();

        // Take every 2-pair and count the number that they have in common, removing from the list
        let mut itr1 = self.outgoing.iter();
        while let Some(left) = itr1.next() {
            let mut itr2 = itr1.clone();
            while let Some(right) = itr2.next() {
                // Only count if these two are connected
                if left.1.contains(right.0) {
                    assert!(right.1.contains(left.0));
                    // Get all of the third-s
                    let shared = left.1.intersection(right.1);
                    for third in shared {
                        threes.insert(NetworkThree::from(left.0, right.0, third));
                    }
                }
            }
        }

        // We only want connections that contain a 't'
        let filtered = threes.iter().filter(|x| {
            x.starts_with_t
        });

        // Debug only
        let mut list: Vec<&NetworkThree> = filtered.clone().collect();
        list.sort();
        list.dedup();
        // Check them!
        for el in list {
            let map = self.outgoing.get(el.first()).unwrap();
            assert!(map.contains(el.second()));
            assert!(map.contains(el.third()));
            let map = self.outgoing.get(el.second()).unwrap();
            assert!(map.contains(el.first()));
            assert!(map.contains(el.third()));
            let map = self.outgoing.get(el.third()).unwrap();
            assert!(map.contains(el.first()));
            assert!(map.contains(el.second()));
        }

        filtered.count().to_string()
    }

    fn part2(&self) -> String {
        // The largest connected component can be determined by looking at the number of edges
        // a node has.
        let mut outgoing: Vec<(&String, &HashSet<String>)> = self.outgoing.iter().collect();
        outgoing.sort_by(|a, b| a.1.len().cmp(&b.1.len()));

        let r = HashSet::new();
        let p = self.outgoing.keys().cloned().collect::<HashSet<_>>();
        let x = HashSet::new();

        self.find_largest_clique(r, p, x).unwrap().to_string()
    }
}
