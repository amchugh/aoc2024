
use crate::days::Solution;

#[derive(Debug)]
pub struct Day7 {
    // State generated by `parse_input`
    equations: Vec<(i64, Vec<i64>)>
}

impl Day7 {
    // Needed for creating a blank day
    pub fn new() -> Day7 {
        Day7 { equations: vec![] }
    }
}

impl Solution for Day7 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.equations = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        self.equations = file_contents.split("\n").map(|line| {
            let mut itr = line.split(": ");
            let target = itr.next().unwrap().parse().unwrap();
            let rest = itr.next().unwrap().split(" ").map(|x| x.parse().unwrap()).collect();
            (target, rest)
        }).collect()
    }

    fn part1(&self) -> String {
        self.equations.iter().filter_map(|x| {
            let mut possible = vec![];
            let mut itr = x.1.iter();
            possible.push(*itr.next().unwrap());
            for i in itr {
                let mut next_possible = vec![];
                for p in possible {
                    next_possible.push(p * i);
                    next_possible.push(p + i);
                }
                possible = next_possible;
            }
            if possible.contains(&x.0) {
                Some(x.0)
            } else {
                None
            }
        }).sum::<i64>().to_string()
    }

    fn part2(&self) -> String {
        self.equations.iter().filter_map(|x| {
            let mut possible = vec![];
            let mut itr = x.1.iter();
            possible.push(*itr.next().unwrap());
            for i in itr {
                let mut next_possible = vec![];
                for p in possible {
                    next_possible.push(p * i);
                    next_possible.push(p + i);
                    // Concatenation
                    let digits = i.ilog10() + 1;
                    next_possible.push(p * (10_i64.pow(digits)) + i);
                }
                possible = next_possible;
            }
            if possible.contains(&x.0) {
                Some(x.0)
            } else {
                None
            }
        }).sum::<i64>().to_string()
    }
}
