use crate::days::Solution;

#[derive(Debug)]
pub struct Day9 {
    // State generated by `parse_input`
    block_counts: Vec<usize>,
    free_spaces: Vec<usize>,
}

impl Day9 {
    // Needed for creating a blank day
    pub fn new() -> Day9 {
        Day9 {
            block_counts: vec![],
            free_spaces: vec![],
        }
    }
}

impl Solution for Day9 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        todo!()
    }

    fn parse_input(&mut self, file_contents: &str) {
        let numbers: Vec<u32> = file_contents.chars().map(|x| x.to_digit(10).unwrap()).collect();
        assert!(numbers.len() % 2 == 1);
        self.block_counts.reserve(numbers.len() / 2 + 1);
        self.free_spaces.reserve(numbers.len() / 2);
        for block_count in numbers.iter().step_by(2) {
            self.block_counts.push(*block_count as usize);
        }
        let mut skip_first = numbers.iter();
        skip_first.next();
        for free_space in skip_first.step_by(2) {
            self.free_spaces.push(*free_space as usize);
        }
    }

    fn part1(&self) -> String {
        let mut total = 0;

        let mut left_idx = 0;
        let mut right_idx = self.block_counts.len() - 1;
        let mut right_remaining = self.block_counts[right_idx];
        let mut current_block_idx = 0 as usize;

        while left_idx < right_idx {
            // Fully consume the left one
            let count = self.block_counts[left_idx];
            // todo:: better way of doing this
            for i in 0..count {
                total += (current_block_idx + i) * left_idx;
            }
            current_block_idx += count;
            // Now deal with the blank space in-between
            let mut blank_count = self.free_spaces[left_idx];
            while blank_count > 0 {
                // Take as much as possible from the right
                if right_remaining > blank_count {
                    for i in 0..blank_count {
                        total += (current_block_idx + i) * right_idx;
                    }
                    current_block_idx += blank_count;
                    right_remaining -= blank_count;
                    break;
                } else {
                    // Take the rest of right remaining and move to the next one
                    for i in 0..right_remaining {
                        total += (current_block_idx + i) * right_idx;
                    }
                    current_block_idx += right_remaining;
                    blank_count -= right_remaining;
                    right_idx -= 1;
                    right_remaining = self.block_counts[right_idx];
                }
            }
            left_idx += 1;
        }
        assert!(right_idx == left_idx);

        // Need to consume the rest of the right remaining
        for i in 0..right_remaining {
            total += (current_block_idx + i) * right_idx;
        }
        current_block_idx += right_remaining;

        assert!(current_block_idx == self.block_counts.iter().sum());

        total.to_string()
    }

    fn part2(&self) -> String {
        // Brute forcing :(

        // Figure out the first index of all the free spaces
        let mut free_space_positions: Vec<(usize, usize)> = vec![];
        free_space_positions.reserve(self.free_spaces.len());

        let mut block_count_positions: Vec<(usize, usize)> = vec![];
        block_count_positions.reserve(self.block_counts.len());

        {
            let mut starting_idx = 0;
            for i in 0..self.free_spaces.len() {
                block_count_positions.push((self.block_counts[i], starting_idx));
                starting_idx += self.block_counts[i];
                free_space_positions.push((self.free_spaces[i], starting_idx));
                starting_idx += self.free_spaces[i];
            }
            // Push the last block count too
            block_count_positions.push((self.block_counts[self.block_counts.len() - 1], starting_idx));

            let bs: usize = self.block_counts.iter().sum();
            let fs: usize = self.free_spaces.iter().sum();
            let last = self.block_counts.last().unwrap();

            assert!(bs + fs == starting_idx + last);
        }

        // Starting from the right, try and place it. Regardless if we moved it, add its position total.
        // let mut right_idx = self.block_counts.len() - 1;
        let mut total = 0;
        for (block_id, (count, starting_idx)) in block_count_positions.iter().enumerate().rev() {
            let mut placed = false;
            // Try and find an earlier slot to put this
            for i in 0..block_id {
                let space = free_space_positions.get_mut(i).unwrap();
                // See if we can place this block here
                if space.0 >= *count {
                    // Put them in
                    for idx in space.1..space.1 + count {
                        total += idx * block_id;
                    }
                   
                    // We took this space, so remember that.
                    space.0 -= count;
                    space.1 += count;

                    placed = true;
                    break;
                }
            }

            if !placed {
                // Place it where it lies
                for idx in *starting_idx..starting_idx + count {
                    total += idx * block_id;
                }
            }
        }

        total.to_string()
    }
}