
use std::collections::HashSet;

use crate::days::Solution;

type Empty = bool;
type Position = (i32, i32);

#[derive(Clone, Debug, PartialEq, Eq, Hash, Copy)]
enum Direction {
    Up,
    Left,
    Down,
    Right
}

impl Direction {
    fn rotate(&self) -> Direction {
        match &self {
            Direction::Up => Direction::Right,
            Direction::Right => Direction::Down,
            Direction::Down => Direction::Left,
            Direction::Left => Direction::Up,
        }
    }

    fn next(&self, position: Position) -> Position {
        match &self {
            Direction::Up => (position.0, position.1 - 1),
            Direction::Left => (position.0 - 1, position.1),
            Direction::Down => (position.0, position.1 + 1),
            Direction::Right => (position.0 + 1, position.1),
        }
    }
}

#[derive(Clone)]
struct Grid(Vec<Vec<Empty>>);

impl Grid {
    fn get(&self, position: Position) -> Option<Empty> {
        let (x, y) = position;

        if x < 0 || x >= self.0.first().map_or(0, |x| x.len()) as i32 {
            return None;
        }

        if y < 0 || y >= self.0.len() as i32 {
            return None;
        }

        Some(self.0[y as usize][x as usize])
    }
}

pub struct Day6 {
    // State generated by `parse_input`
    map: Grid,
    width: usize,
    start: (i32, i32),
}

impl Day6 {
    // Needed for creating a blank day
    pub fn new() -> Day6 {
        Day6 {  
            map: Grid(vec![]),
            width: 0,
            start: (0, 0),
        }
    }

    fn walk(grid: &Grid, mut position: Position, mut direction: Direction) -> Option<HashSet<(Position, Direction)>> {
        let mut seen = HashSet::new();

        loop {
            if seen.contains(&(position, direction)) {
                // We've already been here and therefore are cycling
                return None;
            }
            seen.insert((position, direction));

            let next_position = direction.next(position);

            let result = grid.get(next_position);
            if result.is_none() {
                // We escaped the maze.
                return Some(seen);
            }

            let result: Empty = result.unwrap();
            if result {
                position = next_position;
            } else {
                direction = direction.rotate();
            }
        }
    }
}

impl Solution for Day6 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.map.0 = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        self.map.0 = file_contents.split("\n").enumerate().map(|(y, line)| {
            line.chars().enumerate().map(|(x, c)| {
                match c {
                    '.' => true,
                    '^' => {
                        self.start = (x.try_into().unwrap(), y.try_into().unwrap());
                        true
                    },
                    '#' => false,
                    _ => { panic!("bad character {x}"); }
                }
            }).collect::<Vec<Empty>>()
        }).collect();
        self.width = self.map.0[0].len();
    }

    fn part1(&self) -> String {
        Self::walk(&self.map, self.start, Direction::Up)
            .unwrap()
            .into_iter()
            .map(|(pos, _)| pos)
            .collect::<HashSet<Position>>()
            .len()
            .to_string()
    }

    fn part2(&self) -> String {
        // Get all the positions on the original path
        let mut block_positions = Self::walk(&self.map, self.start, Direction::Up)
            .unwrap()
            .into_iter()
            .map(|(pos, _)| pos)
            .collect::<HashSet<Position>>();
        // Can't block the start
        block_positions.remove(&self.start);
        let block_positions = block_positions;

        // Create a copy of the grid to reuse
        let mut alternate = self.map.clone();

        // Put a block at every position, then total the number that don't make it.
        block_positions.into_iter().map(|block| {
            debug_assert!(alternate.0[block.1 as usize][block.0 as usize] == true);
            alternate.0[block.1 as usize][block.0 as usize] = false;
            let res = Self::walk(&alternate, self.start, Direction::Up);
            alternate.0[block.1 as usize][block.0 as usize] = true;
            res.is_none() as u64
        }).sum::<u64>().to_string()
    }
}
