
use std::collections::{HashMap, HashSet};

use crate::days::Solution;

#[derive(Clone, Debug, PartialEq)]
enum Direction {
    Up,
    Left,
    Down,
    Right
}

impl Direction {
    fn to_idx(&self) -> usize {
        match &self {
            Direction::Up => 0,
            Direction::Left => 1,
            Direction::Down => 2,
            Direction::Right => 3,
        }
    }

    fn next(&self) -> Direction {
        match &self {
            Direction::Up => Direction::Left,
            Direction::Left => Direction::Down,
            Direction::Down => Direction::Right,
            Direction::Right => Direction::Up,
        }
    }
}

type Empty = bool;

#[derive(Clone, Debug)]
struct Blocker {
    seen: [bool; 4],
    x: usize,
    y: usize,
}

impl Blocker {
    fn new(x: usize, y: usize) -> Blocker {
        Blocker { seen: [false, false, false, false], x, y }
    }
}

#[derive(Debug)]
pub struct Day6 {
    // State generated by `parse_input`
    map: Vec<Vec<Empty>>,
    width: usize,
    start: (usize, usize),
}

impl Day6 {
    // Needed for creating a blank day
    pub fn new() -> Day6 {
        Day6 {  
            map: vec![],
            width: 0,
            start: (0, 0),
        }
    }

    fn position_to_idx<T: Into<usize>>(&self, x: T, y: T) -> Option<usize> {
        let x: usize = x.into();
        let y: usize = y.into();

        if x < 0 || x >= self.width {
            return None;
        }

        if y < 0 || y >= self.map.len() {
            return None;
        }

        Some(x as usize + y as usize * self.width)
    }

    fn get(&self, x: i32, y: i32) -> Option<Empty> {
        if x < 0 || x >= self.width as i32 {
            return None;
        }

        if y < 0 || y >= self.map.len() as i32 {
            return None;
        }

        Some(self.map[y as usize][x as usize])
    }
}

impl Solution for Day6 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.map = vec![];
    }

    fn parse_input(&mut self, file_contents: &str) {
        self.map = file_contents.split("\n").map(|line| {
            line.chars().map(|x| {
                match x {
                    '.' => true,
                    '^' => true,
                    '#' => false,
                    _ => { panic!("bad character {x}"); }
                }
            }).collect::<Vec<Empty>>()
        }).collect();

        self.width = self.map[0].len();

        // Find the start point
        let idx = file_contents.find("^").unwrap();
        let x = idx % (self.width + 1);
        let y = idx / (self.width + 1);
        self.start = (x, y);
    }

    fn part1(&self) -> String {
        let mut seen = HashSet::new();
        seen.insert(self.start.0 + self.start.1 * self.width);

        let mut dir = Direction::Up;
        let mut x = self.start.0 as i32;
        let mut y = self.start.1 as i32;

        loop {
            let mut nextx = x;
            let mut nexty = y;
            match dir {
                Direction::Up => { nexty -= 1},
                Direction::Left => { nextx += 1},
                Direction::Down => { nexty += 1},
                Direction::Right => { nextx -= 1},
            };
            // See what we would be on
            let result = self.get(nextx, nexty);
            if result.is_none() {
                break
            }
            let result: Empty = result.unwrap();
            if result {
                x = nextx;
                y = nexty;
                seen.insert(self.position_to_idx(x as usize, y as usize).unwrap());
            } else {
                dir = dir.next();
            }
        }

        // for y in 0..self.map.len() {
        //     let row = &self.map[y];
        //     for x in 0..row.len() {
        //         if row[x] {
        //             if x == self.start.0 && y == self.start.1 {
        //                 print!("$");
        //             } else if seen.contains(&(x + y * self.width)) {
        //                 print!(".");
        //             } else {
        //                 print!(" ");
        //             }
        //         } else {
        //             assert!(seen.contains(&(self.position_to_idx(x, y).unwrap())) == false);
        //             print!("#");
        //         }
        //     }
        //     println!();
        // }

        seen.len().to_string()
    }

    fn part2(&self) -> String {
        // Get all the blockers on the map
        let mut block_map = HashMap::new();
        for y in 0..self.map.len() {
            for x in 0..self.width {
                if self.map[y][x] == false {
                    // Create a blocker here
                    let idx = self.position_to_idx(x, y).unwrap();
                    let block = Blocker::new(x, y);
                    let res = block_map.insert(idx, block);
                    assert!(res.is_none());
                }
            }
        }

        // Now we will traverse again. This time, every time we hit a blocker, we will mark what direction we came from
        let mut dir = Direction::Up;
        let mut x = self.start.0 as i32;
        let mut y = self.start.1 as i32;

        let mut positions = vec![];

        loop {
            let mut nextx = x;
            let mut nexty = y;
            match dir {
                Direction::Up => { nexty -= 1},
                Direction::Left => { nextx += 1},
                Direction::Down => { nexty += 1},
                Direction::Right => { nextx -= 1},
            };
            // See what we would be on
            let result = self.get(nextx, nexty);
            if result.is_none() {
                break
            }
            let result: Empty = result.unwrap();
            if result {
                x = nextx;
                y = nexty;
                positions.push((x, y, dir.clone()));
            } else {
                // // Mark that block as seen from that direction
                // let block = block_map.get_mut(&(self.position_to_idx(nextx as usize, nexty as usize).unwrap())).unwrap();
                // let idx = dir.to_idx();
                // assert!(block.seen[idx] == false);
                // block.seen[idx] = true;
                dir = dir.next();
            }
        }

        // We should not have logged the start position
        assert!(positions.iter().find(|p| {
            p.0 as usize == self.start.0 && p.1 as usize == self.start.1 && p.2 == Direction::Up
        }).is_none());

        dbg!(&positions);

        // Now, we will go through the whole path again. This time, we will ask, "if we turned at this point, will we escape the map without repeating?"
        let total: usize = positions.iter().map(|p| {
            let mut x = p.0;
            let mut y = p.1;
            let mut dir = p.2.next();
            let mut local_block_map = block_map.clone();

            loop {
                let mut nextx = x;
                let mut nexty = y;
                match dir {
                    Direction::Up => { nexty -= 1},
                    Direction::Left => { nextx += 1},
                    Direction::Down => { nexty += 1},
                    Direction::Right => { nextx -= 1},
                };
                // See what we would be on
                let result = self.get(nextx, nexty);
                if result.is_none() {
                    return 0;
                }
                let result: Empty = result.unwrap();
                if result {
                    x = nextx;
                    y = nexty;
                } else {
                    // We have no choice but to turn
                    // Make sure we haven't already hit this one
                    let block = local_block_map.get_mut(&(self.position_to_idx(nextx as usize, nexty as usize).unwrap())).unwrap();
                    let idx = dir.to_idx();
                    if block.seen[idx] {
                        dbg!(&block);
                        panic!();
                        return 1;
                    }
                    block.seen[idx] = true;
                    dir = dir.next();
                }
            }
        }).sum();

        // total.to_string()
        "Not Implemented".to_string()
    }
}
