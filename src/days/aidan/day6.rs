
use std::collections::HashSet;

use crate::days::Solution;

use super::shared::{Direction, Position, Grid};

type Empty = bool;

pub struct Day6 {
    // State generated by `parse_input`
    map: Grid<Empty>,
    start: Position,
}

impl Day6 {
    // Needed for creating a blank day
    pub fn new() -> Day6 {
        Day6 {  
            map: Grid::from(vec![]),
            start: (0, 0),
        }
    }

    fn walk(grid: &Grid<Empty>, mut position: Position, mut direction: Direction) -> Option<HashSet<(Position, Direction)>> {
        let mut seen = HashSet::new();

        loop {
            if seen.contains(&(position, direction)) {
                // We've already been here and therefore are cycling
                return None;
            }
            seen.insert((position, direction));

            let next_position = direction.next(&position);

            let result = next_position.and_then(|x| grid.get(&x));
            if result.is_none() {
                // We escaped the maze.
                return Some(seen);
            }

            let result: Empty = *result.unwrap();
            if result {
                position = next_position.unwrap();
            } else {
                direction = direction.clockwise();
            }
        }
    }
}

impl Solution for Day6 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.map = Grid::from(vec![]);
    }

    fn parse_input(&mut self, file_contents: &str) {
        let map = file_contents.split("\n").enumerate().map(|(y, line)| {
            line.chars().enumerate().map(|(x, c)| {
                match c {
                    '.' => true,
                    '^' => {
                        self.start = (x.try_into().unwrap(), y.try_into().unwrap());
                        true
                    },
                    '#' => false,
                    _ => { panic!("bad character {x}"); }
                }
            }).collect::<Vec<Empty>>()
        }).collect();

        self.map = Grid::from(map);
    }

    fn part1(&self) -> String {
        Self::walk(&self.map, self.start, Direction::Up)
            .unwrap()
            .into_iter()
            .map(|(pos, _)| pos)
            .collect::<HashSet<Position>>()
            .len()
            .to_string()
    }

    fn part2(&self) -> String {
        // Get all the positions on the original path
        let mut block_positions = Self::walk(&self.map, self.start, Direction::Up)
            .unwrap()
            .into_iter()
            .map(|(pos, _)| pos)
            .collect::<HashSet<Position>>();
        // Can't block the start
        block_positions.remove(&self.start);
        let block_positions = block_positions;

        // Create a copy of the grid to reuse
        let mut alternate = self.map.clone();

        // Put a block at every position, then total the number that don't make it.
        block_positions.into_iter().map(|block| {
            assert!(alternate.get(&block) == Some(&true));
            alternate.set(&block, false).unwrap();
            let res = Self::walk(&alternate, self.start, Direction::Up);
            alternate.set(&block, true).unwrap();
            res.is_none() as u64
        }).sum::<u64>().to_string()
    }
}
