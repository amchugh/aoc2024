
use std::{collections::VecDeque};

use crate::days::Solution;

#[derive(Clone, Debug, PartialEq, Eq)]
enum Direction {
    North, South, East, West
}

impl Direction {
    fn from(c: char) -> Option<Direction> {
        match c {
            '^' => Some(Direction::North),
            '<' => Some(Direction::West),
            '>' => Some(Direction::East),
            'v' => Some(Direction::South),
            _ => None
        }

    }
    fn translate(&self, pos: &(usize, usize)) -> (usize, usize) {
        match &self {
            Direction::North => (pos.0, pos.1 - 1),
            Direction::South => (pos.0, pos.1 + 1),
            Direction::East =>  (pos.0 + 1, pos.1),
            Direction::West =>  (pos.0 - 1, pos.1),
        }
    }
}

#[derive(Debug)]
pub struct Day15 {
    // State generated by `parse_input`
    grid: Vec<Vec<char>>,
    movements: Vec<Direction>,
    start: (usize, usize),
}

impl Day15 {
    // Needed for creating a blank day
    pub fn new() -> Day15 {
        Day15 { grid: vec![], movements: vec![], start: (0, 0) }
    }

    #[allow(unused)]
    fn print_grid(grid: &Vec<Vec<char>>) {
        for row in grid {
            println!("{}", row.iter().collect::<String>());
        }
    }

    fn sum_block_scores(grid: &Vec<Vec<char>>, search: char) -> usize {
        let mut total = 0;
        for (y, row) in grid.iter().enumerate() {
            for (x, c) in row.iter().enumerate() {
                if *c == search {
                    total += y * 100 + x;
                }
            }
        }
        total
    }

    fn find_connected_blocks(grid: &Vec<Vec<char>>, position: (usize, usize), direction: &Direction) -> Vec<(usize, usize)> {
        // Find all the blocks connected to the block underneath
        let mut result = vec![];
        let mut queue = VecDeque::new();

        // Only adding the '['
        if grid[position.1][position.0] == ']' {
            queue.push_back((position.0 - 1, position.1));
        } else {
            assert!(grid[position.1][position.0] == '[');
            queue.push_back(position);            
        }

        loop {
            let top = queue.pop_front();
            if top.is_none() {
                break;
            }
            let top = top.unwrap();
            assert!(grid[top.1][top.0] == '[');
            assert!(result.contains(&top) == false);
            result.push(top);

            // See if either in the target direction are blocks
            let candidate = direction.translate(&top);
            if grid[candidate.1][candidate.0] == ']' {
                let other = (candidate.0 - 1, candidate.1);
                assert!(grid[other.1][other.0] == '[');
                if queue.contains(&other) == false {
                    queue.push_back(other);
                }
            } else if grid[candidate.1][candidate.0] == '[' {
                assert!(grid[candidate.1][candidate.0 + 1] == ']');
                if queue.contains(&candidate) == false {
                    queue.push_back(candidate);
                }
            }

            if grid[candidate.1][candidate.0 + 1] == '[' {
                assert!(grid[candidate.1][candidate.0 + 2] == ']');
                let wanted = (candidate.0 + 1, candidate.1);
                if queue.contains(&wanted) == false {
                    queue.push_back(wanted);
                }
            }
        }
        result
    }
}

impl Solution for Day15 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        todo!()
    }

    fn parse_input(&mut self, file_contents: &str) {
        let mut itr = file_contents.split("\n\n");
        self.grid = itr.next().unwrap().split("\n").map(|line| line.chars().collect()).collect();
        self.movements = itr.next().unwrap().chars().filter(|x| *x != '\n').map(|x| Direction::from(x).unwrap()).collect();

        // Find the start
        'outer: for (y, row) in self.grid.iter().enumerate() {
            for (x, c) in row.iter().enumerate() {
                if *c == '@' {
                    self.start = (x, y);
                    break 'outer;
                }
            }
        }

        // And remove the start symbol for simplicity
        self.grid[self.start.1][self.start.0] = '.';
    }

    fn part1(&self) -> String {
        let mut grid = self.grid.clone();
        let mut position = self.start;

        for dir in &self.movements {
            assert!(grid[position.1][position.0] == '.');
            // Try and move that way
            let next = dir.translate(&position);
            let occupying = grid[next.1][next.0];
            // If it's free, it is simple.
            if occupying == '.' {
                position = next;
                continue;
            }
            // Same if it is blocked
            if occupying == '#' {
                continue;
            }
            // If there is a block there, we need to try and move it.
            assert!(occupying == 'O');
            let first_block_position = next;
            let mut next = dir.translate(&next);
            // We need to find the first non-block space in this line
            while grid[next.1][next.0] == 'O' {
                next = dir.translate(&next);
            }
            // Now next is either a free space or blocked.
            let occupying = grid[next.1][next.0];
            // Can't do anything if it is blocked
            if occupying == '#' {
                continue;
            }
            // If it is unblocked, we will swap the first block to that place
            assert!(occupying == '.');
            grid[next.1][next.0] = 'O';
            grid[first_block_position.1][first_block_position.0] = '.';
            position = first_block_position;
        }

        Self::sum_block_scores(&grid, 'O').to_string()
    }

    fn part2(&self) -> String {
        // Need to make the new grid
        let mut grid: Vec<Vec<char>> = self.grid.iter().map(|line| {
            let mut row = vec![];
            for c in line {
                match *c {
                    '.' => {row.push('.'); row.push('.');}
                    'O' => {row.push('['); row.push(']');}
                    '#' => {row.push('#'); row.push('#');}
                    _ => {panic!();}
                }
            }
            row
        }).collect();
        let mut position = (self.start.0 * 2, self.start.1);

        for dir in &self.movements {
            assert!(grid[position.1][position.0] == '.');
            // Try and move that way
            let next = dir.translate(&position);
            let occupying = grid[next.1][next.0];
            // If it's free, it is simple.
            if occupying == '.' {
                position = next;
                continue;
            }
            // Same if it is blocked
            if occupying == '#' {
                continue;
            }
            // If there is a block there, we need to try and move it.
            assert!(occupying == '[' || occupying == ']');
            // This is more complicated, only for up and down.
            if *dir == Direction::East || *dir == Direction::West {
                let first_block_position = next;
                let mut next = dir.translate(&first_block_position);
                // We need to find the first non-block space in this line
                while grid[next.1][next.0] == '[' || grid[next.1][next.0] == ']' {
                    next = dir.translate(&next);
                }
                // Now next is either a free space or blocked.
                let occupying = grid[next.1][next.0];
                // Can't do anything if it is blocked
                if occupying == '#' {
                    continue;
                }
                // If it is unblocked, we need to scoot everything down.
                assert!(occupying == '.');

                // Do the same thing again, but swap the characters
                let mut next = dir.translate(&first_block_position);
                while grid[next.1][next.0] == '[' || grid[next.1][next.0] == ']' {
                    grid[next.1][next.0] = match grid[next.1][next.0] {
                        '[' => ']',
                        ']' => '[',
                        _ => {panic!();},
                    };
                    next = dir.translate(&next);
                }

                // And now do the last one
                assert!(grid[next.1][next.0] == '.');
                grid[next.1][next.0] = match grid[first_block_position.1][first_block_position.0] {
                    '[' => ']',
                    ']' => '[',
                    _ => {panic!();},
                };

                // Swap the first
                grid[first_block_position.1][first_block_position.0] = '.';

                // Update position
                position = first_block_position;
            } else {
                // We are either moving up or moving down
                // Figure out if the block is clear or not
                let connected_blocks = Self::find_connected_blocks(&grid, next, dir);
                let clear_to_move = connected_blocks.iter().all(|x| {
                    let left = dir.translate(x);
                    let right = (left.0 + 1, left.1);
                    grid[left.1][left.0] != '#' && grid[right.1][right.0] != '#'
                });
                if !clear_to_move {
                    continue;
                }

                // We need to move all the blocks.
                for block in connected_blocks.iter().rev() {
                    let left = dir.translate(&block);
                    grid[block.1][block.0] = '.';
                    grid[block.1][block.0 + 1] = '.';
                    grid[left.1][left.0] = '[';
                    grid[left.1][left.0 + 1] = ']';
                }

                // Update position
                position = next;
            }
        }

        Self::sum_block_scores(&grid, '[').to_string()
    }
}
