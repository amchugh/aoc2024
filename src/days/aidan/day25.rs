
use crate::days::Solution;

#[derive(Debug)]
pub struct Day25 {
    // State generated by `parse_input`
    keys: Vec<[u64; 5]>,
    locks: Vec<[u64; 5]>,
}

impl Day25 {
    // Needed for creating a blank day
    pub fn new() -> Day25 {
        Day25 { keys: vec![], locks: vec![] }
    }
}

impl Solution for Day25 {
    fn reset(&mut self) {
        // Should probably do the same thing new() does.
        self.keys = vec![];
        self.locks = vec![];
   }

    fn parse_input(&mut self, file_contents: &str) {
        for item in file_contents.split("\n\n") {
            let mut lines = item.split("\n");

            let first = lines.next().unwrap();
            let one = lines.next().unwrap();
            let two = lines.next().unwrap();
            let three = lines.next().unwrap();
            let four = lines.next().unwrap();
            let five = lines.next().unwrap();
            let last = lines.next().unwrap();
            let is_key;
            let order;

            if first == "....." {
                is_key = true;
                order = [five, four, three, two, one];
                assert!(last == "#####");
            } else {
                is_key = false;
                order = [one, two, three, four, five];
                assert!(first == "#####");
                assert!(last == ".....");
            }

            let mut counts: [u64; 5] = [0, 0, 0, 0, 0];
            for (count, layer) in order.iter().enumerate() {
                for idx in 0..5 {
                    if counts[idx] == count as u64 {
                        // Eligible
                        if layer.chars().nth(idx).unwrap() == '#' {
                            counts[idx] += 1;
                        }
                    }
                }
            }

            if is_key {
                self.keys.push(counts);
            } else {
                self.locks.push(counts);
            }
        }

        let before_len = self.keys.len();
        self.keys.sort();
        self.keys.dedup();
        assert!(before_len == self.keys.len());

        let before_len = self.locks.len();
        self.locks.sort();
        self.locks.dedup();
        assert!(before_len == self.locks.len());
    }

    fn part1(&self) -> String {
        self.keys.iter().map(|key| {
            self.locks.iter().filter(|lock| {
                key.iter().zip(lock.iter()).all(|(k, l)| k + l <= 5)
            }).count()
        }).sum::<usize>().to_string()
    }

    fn part2(&self) -> String {
        "No Part 2".to_owned()
    }
}
